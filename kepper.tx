// /* cchek and create the number of pipes we have in our token*/
// int	iterate_pipe_index(t_infos *tokens, char ***envp)
// {
// 	int		i;
// 	int		e_status;
// 	t_pipe	*pipe;

// 	i = 0;
// 	while (i < tokens->pipe_index)
// 	{
// 		pipe = tokens->pipes[i];
// 		e_status = ft_create_pipe(pipe, envp, tokens);
// 		i++;
// 	}
// 	return (e_status);
// }

// /* check for redir, then handles redir before exit */
// int	handle_builtin(t_command *cmd, t_infos *tokens, char ***envp, int *status)
// {
// 	if (is_builtin(cmd->name))
// 	{
// 		if (ft_strcmp("exit", cmd->name) == 0)
// 		{
// 			*status = -5;
// 			if (cmd->redir_count > 0)
// 			ft_execute(cmd, envp, tokens);
// 				handle_redirections(cmd, tokens);
// 			ft_execute(cmd, envp, tokens);
// 		}
// 		else
// 		{
// 			*status = 1;
// 			if (cmd->redir_count > 0)
// 				handle_redirections(cmd, tokens);
// 			ft_execute(cmd, envp, tokens);
// 		}
// 	}
// 	else
// 		*status = 0;
// 	return (*status);
// }

// /* helper for execute_command to handle the child process if created*/
// int	run_child(t_infos *tokens, char ***envp)
// {
// 	setup_signal_handlers_child();
// 	if (tokens->commands[0]->redir_count > 0)
// 	{
// 		handle_redirections(tokens->commands[0], tokens);
// 		if (tokens->e_code == 1)
// 			return (1);
// 	}
// 	tokens->e_code = ft_execute(tokens->commands[0], envp, tokens);
// 	return (tokens->e_code);
// }

// int	handle_forked_process(t_infos *tokens, char ***envp)
// {
// 	pid_t	pid;

// 	pid = fork_process();
// 	if (pid == 0)
// 	{
// 		setup_signal_handlers_child();
// 		tokens->e_code = run_child(tokens, envp);
// 		exit(tokens->e_code);
// 	}
// 	else if (pid > 0)
//         return (pid);
// 	else
// 		return (-1);
// }
// // Function to handle the parent process logic after fork
// int	handle_parent_process(pid_t pid, t_infos *tokens)
// {
// 	int	status;

// 	signal(SIGINT, SIG_IGN);
// 	waitpid(pid, &status, 0);
// 	signal(SIGINT, handle_sigint);
// 	if (status == 256)
// 	{
// 		tokens->e_code = -5;
// 		return (tokens->e_code);
//     }
// 	if (WIFEXITED(status))
//         tokens->e_code = WEXITSTATUS(status);
// 	else if (WIFSIGNALED(status))
// 	{
// 		if (WTERMSIG(status) == SIGINT)
// 			g_int = 0;  // Child exited due to Ctrl + C, clear g_int in parent
// 	}
// 	if (g_int)
// 	{
// 		tokens->e_code = 130;
// 		g_int = 0;
// 	}
//     return (tokens->e_code);
// }

// /* my data was stored in cmd , but if pipe exist then we store in
// pipe->cmd1(start < pipe(position) and cmd2(pipe(position + 1) < NULL || next_pipe)) 
// sso if (pipe exist), we use pipe to process the cmds and exectute but if(!pipe exist)
// we use the copy of cmd and then set up child fork is necessary and then execute */
// int	execute_command(t_infos *tokens, char ***envp) {
//     pid_t	pid;
// 	int		status;

// 	if (tokens->pipe_index > 0)
// 		tokens->e_code = iterate_pipe_index(tokens, envp);
// 	else
// 	{
// 		handle_builtin(tokens->commands[0], tokens, envp, &status);
// 		if ((status == -5) || (status == 1))
//             return (status);
//         pid = handle_forked_process(tokens, envp);
//         if (pid > 0)
// 		{
// 			return (handle_parent_process(pid, tokens));
// 		}
// 	}
// 	return (tokens->e_code);
// }

/* my data was stored in cmd , but if pipe exist then we store in
pipe->cmd1(start < pipe(position) and cmd2(pipe(position + 1) < NULL || next_pipe)) 
sso if (pipe exist), we use pipe to process the cmds and exectute but if(!pipe exist)
we use the copy of cmd and then set up child fork is necessary and then execute */
// int	execute_command(t_infos *tokens, char ***envp)
// {
// 	pid_t	pid;
// 	int		status;

// 	if (tokens->pipe_index > 0)
// 		tokens->e_code = iterate_pipe_index(tokens, envp);
// 	else
// 	{
// 		handle_builtin(tokens->commands[0], tokens, envp, &status);
// 		if (status == -5)
// 			return (status);
// 		else if (status == 1)
// 			return (status);
// 		pid = fork();
// 		if (pid == 0)
// 		{
// 			setup_signal_handlers_child();
// 			tokens->e_code = run_child(tokens, envp);
// 			exit (tokens->e_code);
// 		}
// 		else if (pid > 0)
// 		{
// 			signal(SIGINT, SIG_IGN);
// 			waitpid(pid, &status, 0);
// 			if (status == 256)
// 				return (-5);
// 			signal(SIGINT, handle_sigint);
			
// 			if (WIFEXITED(status)){
// 				tokens->e_code = WEXITSTATUS(status);}
// 			else if (WIFSIGNALED(status)) {
//                if (WTERMSIG(status) == SIGINT) {
//             	g_int = 0;  // Child exited due to Ctrl + C, clear g_int in parent
//         }
//             }
// 			if (g_int)
// 			{
//                 tokens->e_code = 130;
// 				g_int = 0;
//             }
// 			return (tokens->e_code);
// 		}
// 	}
// 	return (tokens->e_code);
// }

/* Checks if execution is builtin function and then handle it
if(!builtin) it check if path is in Path and then execute.*/
// int	ft_execute(t_command *command, char ***envp, t_infos *tokens)
// {
// 	char	*path;

// 	if (is_builtin(command->name))
// 		tokens->e_code= ft_check_builtin(command, envp);
// 	else
// 	{
// 		path = ft_access(command->name, (*envp));
// 		if (path == NULL)
// 		{
// 			ft_putstr_fd("command \'", STDERR_FILENO);
// 			ft_putstr_fd(command->name, STDERR_FILENO);
// 			ft_putstr_fd("\' not found\n", STDERR_FILENO);
// 			tokens->e_code = 127;
// 			return (tokens->e_code);
// 		}
// 		if (execve(path, command->args, (*envp)) == -1)
// 		{
// 			perror("EXECVE");
// 			free(path);
// 			tokens->e_code = 13;
// 			return (tokens->e_code);
// 		}
// 	}
// 	return (tokens->e_code);
// }


// int	is_dollar_char(t_command *cmd, char *token_array[], int *start,
// 		char *envp[], t_infos *tokens)
// {
// 	char	*value;

// 	value = ft_special_char(envp, token_array[*start], cmd, tokens);
// 	if (value)
// 	{
// 		cmd->args[cmd->i++] = value;
// 		*start = *start + 1;
// 		return (1);
// 	}
// 	return (0);
// }

// char	*ft_special_char(char *envp[], const char *str, t_command *cmd, t_infos *tokens)
// {
// 	char	*value;
// 	char	*new_value;
// 	char	*get_env;
// 	char	*env_key;

// 	value = ft_strchr(str, '$');
// 	if (value)
// 	{
// 		value++;
// 		if (ft_strncmp(value, "?", 1) == 0)
// 			new_value = ft_strdup(ft_itoa(tokens->e_code));
// 		else
// 		{
// 			env_key = ft_write_env(value);
// 			get_env = get_env_var(envp, env_key);
// 			if (get_env == NULL)
// 				new_value = ft_strdup("404");
// 			else
// 				new_value = ft_strdup(get_env);
// 		}
// 		return (new_value);
// 	}
// 	return (NULL);
// }

// char	*ft_special_char(char *args, char **before_env, char **after_env, t_infos *tokens)
// {
// 	char	*value;
// 	char	*new_value = NULL;
// 	char	*get_env;
// 	char	*env_key;

// 	value = ft_strchr(args, '$');
// 	if (value)
// 	{
// 		if (args[0] == '\'')
// 			return (new_value);
// 		*before_env = ft_substr(args, 0, (value - args));
// 		value++;
// 		if (ft_strncmp(value, "?", 1) == 0)
// 		{
// 			*after_env = ft_strdup(value + 1);
// 			new_value = ft_strdup(ft_itoa(tokens->e_code));
// 		}
// 		else
// 		{
// 			env_key = ft_write_env(value);
// 			get_env = get_env_var(*(tokens->envp), env_key);
// 			if (get_env == NULL)
// 				return ("");
// 			else
// 			{
// 				new_value = ft_strdup(get_env);
// 				*after_env = ft_strdup(value + ft_strlen(env_key));
// 			}
// 		}
// 		return (new_value);
// 	}
// 	return (new_value);
// }

// int	is_dollar_char(t_command *cmd, char *token_array, int *start, t_infos *tokens)
// {
// 	char	*value;
// 	char	*before_env;
// 	char	*after_env;
// 	char	*new_args;

// 	value = ft_special_char(token_array, &before_env, &after_env, tokens);
// 	if (value)
// 	{
// 		if (before_env[0] == '"')
// 			before_env++;
// 		new_args = ft_strjoin(before_env, value);
// 		cmd->args[cmd->i++] = ft_strjoin(new_args, after_env);
// 		(*start)++;
// 		return (1);
// 	}
// 	return (0);
// }



/* this creates the pipe struct which have the cmd1 and cmd2,
the cmd1 keeps all cmd created from the start until a pipe and
cmd2 keep all cmd after the pipe till the next pipe or NULL*/
// void	is_pipe_char(char *token_array[], char *envp[],
// 		t_infos *tokens, t_var *var)
// {
// 	t_pipe		*pipe;

// 	pipe = (t_pipe *)ft_malloc(sizeof(t_pipe));
// 	pipe->cmd1 = ft_create_cmd(var->j, var->i - 1, token_array, envp, tokens);
// 	var->end = var->i + 1;
// 	while (token_array[var->end] && (ft_strcmp(token_array[var->end],
// 				"|") != 0))
// 		var->end++;
// 	pipe->cmd2 = ft_create_cmd(var->i + 1, var->end - 1, token_array, envp, tokens);
// 	tokens->pipes[tokens->pipe_index++] = pipe;
// 	var->j = var->i + 1;
// 	return ;
// }

/* creates the cmd, checks if $, redir and strdup the str found into
the cmd->args every str is kept in cmd->args and the cmd struct is returned*/
// t_command	*ft_create_cmd(int start, int end, char *tokens[], char *envp[], t_var *var)
// {
// 	int			redir_status;
// 	t_command	*cmd;

// 	cmd = (t_command *)ft_malloc(sizeof(t_command));
// 	cmd->redir_cmd = (t_redir **)ft_malloc(sizeof(t_redir *) * INIT_SIZE);
// 	cmd->name = ft_strdup(tokens[start]);
// 	cmd->args = (char **)ft_malloc(sizeof(char *) * (end - start + 2));
// 	cmd->i = 0;
// 	cmd->redir_count = 0;
// 	while (start <= end)
// 	{
// 		if (is_dollar_char(cmd, tokens, &start, envp))
// 			continue ;
// 		redir_status = is_redirection_char(cmd, tokens, &start);
// 		if (redir_status > 0)
// 			continue ;
// 		else if (redir_status < 0)
// 			break ;
// 		cmd->args[cmd->i++] = ft_strdup(tokens[start++]);
// 		cmd->e_status = 0;
// 	}
// 	cmd->args[cmd->i] = NULL;
// 	cmd->redir_cmd[cmd->redir_count] = NULL;
// 	return (cmd);
// }

char	*ft_write_env(char *value)
{
	int		i;
	int		len;
	char	*env_key;

	i = 0;
	while (value[len] != ' ' && value[len] != '\''
		&& value[len] != '"' && value[len] != '\0')
		len++;
	env_key = (char *)malloc(sizeof (char) * (len + 1));
	if (!env_key)
		return (NULL);
	while (*value != ' ' && *value != '\'' && *value != '"'
		&& *value != '\0')
		env_key[i++] = *value++;
	env_key[i] = '\0';
	return (env_key);
}



// int	redirect_input_output(int infile, int outfile, int pipefd[2], int x)
// {
// 	if (x == 1)
// 	{
// 		if (dup2(infile, STDIN_FILENO) == -1)
// 			error();
// 		close(infile);
// 		close(pipefd[0]);
// 		if (dup2(pipefd[1], STDOUT_FILENO) == -1)
// 			error();
// 		close(pipefd[1]);
// 	}
// 	else if (x == 2)
// 	{
// 		close(pipefd[1]);
// 		if (dup2(pipefd[0], STDIN_FILENO) == -1)
// 			error();
// 		close(pipefd[0]);
// 		if (dup2(outfile, STDOUT_FILENO) == -1)
// 			error();
// 		close(outfile);
// 	}
// 	return (0);
// }

// void	execute_command(char *av[], char *envp[], int pipefd[], int process)
// {
// 	int	infile;
// 	int	outfile;

// 	if (process == 1)
// 	{
// 		infile = ft_file(av[1], 0);
// 		redirect_input_output(infile, 0, pipefd, 1);
// 		close(infile);
// 		ft_execute(av, envp, 2);
// 	}
// 	else if (process == 2)
// 	{
// 		outfile = ft_file(av[4], 1);
// 		redirect_input_output(0, outfile, pipefd, 2);
// 		close(outfile);
// 		ft_execute(av, envp, 3);
// 	}
// }

// void	ft_execute(char *av[], char *envp[], int x)
// {
// 	char	*path;
// 	char	**cmd;

// 	path = ft_access(av[x], envp);
// 	if (path == NULL)
// 		bad_arg(x);
// 	cmd = ft_split(av[x], ' ');
// 	if (execve(path, cmd, envp) == -1)
// 	{
// 		free(cmd);
// 		free(path);
// 		error();
// 	}
// }

// char	*ft_access(char *av, char *envp[])
// {
// 	char	**splitted;
// 	char	*path;
// 	int		i;

// 	splitted = check_path(envp);
// 	i = -1;
// 	while (splitted[++i] != NULL)
// 	{
// 		path = join(splitted[i], av);
// 		if (access(path, X_OK) == 0)
// 			break ;
// 		free(path);
// 	}
// 	if (splitted[i] == NULL)
// 	{
// 		ft_cleaner(splitted);
// 		return (NULL);
// 	}
// 	return (path);
// }

// char	*join(char *str, char *av)
// {
// 	char	*path;
// 	char	**cmd;

// 	cmd = ft_split(av, ' ');
// 	str = ft_strjoin(str, "/");
// 	path = ft_strjoin(str, cmd[0]);
// 	free(str);
// 	ft_cleaner(cmd);
// 	return (path);
// }




// void	ft_dup(int pipefd[2], int fd)
// {
// 	if (fd == STDOUT_FILENO)
// 	{
// 		close(pipefd[0]);
// 		if (dup2(pipefd[1], fd) == -1)
// 			errors("dup2 failed\n");
// 		close(pipefd[1]);
// 	}
// 	else if (fd == STDIN_FILENO)
// 	{
// 		close(pipefd[1]);
// 		if (dup2(pipefd[0], fd) == -1)
// 			errors("dup2 failed\n");
// 		close(pipefd[0]);
// 	}
// }

// void	handle_pid(int pipefd[2], t_command *cmd, t_infos *tokens, char ***envp, int stdio)
// {
// 	char *str1 = ft_itoa(cmd->redir_count);
// 	ft_putendl_fd(str1, STDERR_FILENO);
// 	if (cmd->redir_count == 0)
// 		ft_dup(pipefd, stdio);
// 	handle_redirections(cmd, tokens);
// 	if (tokens->e_code == 1)
// 		exit (tokens->e_code);
// 	tokens->e_code = ft_execute(cmd, envp, tokens);
// 	exit (tokens->e_code);
// }

// int	ft_create_pipe(t_pipe *pipe, char ***envp, t_infos *tokens)
// {
// 	int		pipefd[2];
// 	pid_t	pid1;
// 	pid_t	pid2;
// 	int status;

// 	pipe_create(pipefd);
// 	if (pipe->cmd1->name)
// 	{
// 		if (is_builtin(pipe->cmd1->name))
// 		{
// 			if (tokens->save_fdout > 0)
// 				close (tokens->save_fdout);
// 			tokens->save_fdout = dup(STDOUT_FILENO);
// 			char *str = ft_itoa(pipe->cmd1->redir_count);
// 			ft_putendl_fd(str, STDERR_FILENO);
// 			if (pipe->cmd1->redir_count == 0)
// 				dup2(pipefd[1], STDOUT_FILENO);
// 			handle_builtin(pipe->cmd1, tokens, envp, &status);
// 			dup2(tokens->save_fdout, STDOUT_FILENO);
// 		}
// 		else
// 		{
// 			pid1 = fork_process();
// 			if (pid1 == 0)
// 			{
				
// 				handle_pid(pipefd, pipe->cmd1, tokens, envp, STDOUT_FILENO);
				
// 			}
// 		}
//     }
// 	ft_putendl_fd("fuck here", STDERR_FILENO);
// 	if (pipe->cmd2->name)
// 	{
// 		if (is_builtin(pipe->cmd2->name))
// 		{
// 			if (tokens->save_fdin > 0)
// 				close (tokens->save_fdin);
// 			tokens->save_fdin = dup(STDIN_FILENO);
// 			if (pipe->cmd2->redir_count == 0)
// 				dup2(pipefd[0], STDIN_FILENO);
// 			handle_builtin(pipe->cmd2, tokens, envp, &status);
// 			dup2(tokens->save_fdin, STDIN_FILENO);
// 		}
// 		else
// 		{
// 			pid2 = fork_process();
// 			if (pid2 == 0)
// 				handle_pid(pipefd, pipe->cmd2, tokens, envp, STDIN_FILENO);
// 		}
// 	}
// 	close(pipefd[1]);
// 	close(pipefd[0]);
// 	if (!is_builtin(pipe->cmd1->name))
// 		waitpid(pid1, NULL, 0);
// 	if (!is_builtin(pipe->cmd2->name))
// 		waitpid(pid2, NULL, 0);
// 	return (tokens->e_code);
// }



// void	handle_pid1(int pipefd[2], t_pipe *pipe, t_infos *tokens, char **envp[]) {
//     // Set up signal handlers for the first child
//     setup_signal_handlers_child();

//     ft_dup(pipefd, STDOUT_FILENO);
//     handle_redirections(pipe->cmd1, tokens);
//     if (tokens->e_code == 1)
//         exit(tokens->e_code);
//     tokens->e_code = ft_execute(pipe->cmd1, envp, tokens);
//     exit(tokens->e_code);
// }

// void	handle_pid2(int pipefd[2], t_pipe *pipe, t_infos *tokens, char **envp[]) {
//     // Set up signal handlers for the second child
// 	// int	i = 0;
//     setup_signal_handlers_child();

//     ft_dup(pipefd, STDIN_FILENO);
// 	handle_redirections(pipe->cmd2, tokens);
//     if (tokens->e_code == 1)
//         exit(tokens->e_code);
//     tokens->e_code = ft_execute(pipe->cmd2, envp, tokens);
//     exit(tokens->e_code);
// }

// int	ft_create_pipe(t_pipe *pipe, char **envp[], t_infos *tokens) {
//     int pipefd[2];
//     pid_t pid1, pid2;
//     int status;

//     pipe_create(pipefd);
//     pid1 = fork_process();
//     if (pid1 == 0) {
//         handle_pid1(pipefd, pipe, tokens, envp);
//     }

//     pid2 = fork_process();
//     if (pid2 == 0) {
//         handle_pid2(pipefd, pipe, tokens, envp);
//     }

//     close(pipefd[0]);
//     close(pipefd[1]);

//     // Parent process waits for both child processes to complete
//     waitpid(pid1, &status, 0);
//     if (WIFSIGNALED(status)) {
//         tokens->e_code = 128 + WTERMSIG(status); // Handle signal-based termination
//     }

//     waitpid(pid2, &status, 0);
//     if (WIFSIGNALED(status)) {
//         tokens->e_code = 128 + WTERMSIG(status); // Handle signal-based termination
//     }

//     return tokens->e_code;
// }




//  signals shold be checked howto

/* cchek and create the number of pipes we have in our token*/
// int	iterate_pipe_index(t_infos *tokens, char ***envp)
// {
// 	int		i;
// 	int		e_status;
// 	t_pipe	*pipe;

// 	i = 0;
// 	while (i < tokens->pipe_index)
// 	{
// 		pipe = tokens->pipes[i];
// 		e_status = ft_create_pipe(pipe, envp, tokens);
// 		i++;
// 	}
// 	return (e_status);
// }

/* check for redir, then handles redir before exit */
// int	handle_builtin(t_command *cmd, t_infos *tokens, char ***envp, int *status)
// {
// 	if (is_builtin(cmd->name))
// 	{
// 		if (ft_strcmp("exit", cmd->name) == 0)
// 		{
// 			*status = -5;
// 			if (cmd->redir_count > 0)
// 			ft_execute(cmd, envp, tokens);
// 				handle_redirections(cmd, tokens);
// 			ft_execute(cmd, envp, tokens);
// 		}
// 		else
// 		{
// 			*status = 1;
// 			if (cmd->redir_count > 0)
// 				handle_redirections(cmd, tokens);
// 			ft_execute(cmd, envp, tokens);
// 		}
// 	}
// 	else
// 		*status = 0;
// 	return (*status);
// }



/* helper for execute_command to handle the child process if created*/
// int	run_child(t_infos *tokens, char ***envp)
// {
// 	setup_signal_handlers_child();
// 	if (tokens->commands[0]->redir_count > 0)
// 	{
// 		handle_redirections(tokens->commands[0], tokens);
// 		if (tokens->e_code == 1)
// 			return (1);
// 	}
// 	tokens->e_code = ft_execute(tokens->commands[0], envp, tokens);
// 	return (tokens->e_code);
// }

// int	handle_forked_process(t_infos *tokens, char ***envp)
// {
// 	pid_t	pid;

// 	pid = fork_process();
// 	if (pid == 0)
// 	{
// 		setup_signal_handlers_child();
// 		tokens->e_code = run_child(tokens, envp);
// 		exit(tokens->e_code);
// 	}
// 	else if (pid > 0)
//         return (pid);
// 	else
// 		return (-1);
// }
// // Function to handle the parent process logic after fork
// int	handle_parent_process(pid_t pid, t_infos *tokens)
// {
// 	int	status;

// 	signal(SIGINT, SIG_IGN);
// 	waitpid(pid, &status, 0);
// 	signal(SIGINT, handle_sigint);
// 	if (status == 256)
// 	{
// 		tokens->e_code = -5;
// 		return (tokens->e_code);
//     }
// 	if (WIFEXITED(status))
//         tokens->e_code = WEXITSTATUS(status);
// 	else if (WIFSIGNALED(status))
// 	{
// 		if (WTERMSIG(status) == SIGINT)
// 			g_int = 0;  // Child exited due to Ctrl + C, clear g_int in parent
// 	}
// 	if (g_int)
// 	{
// 		tokens->e_code = 130;
// 		g_int = 0;
// 	}
//     return (tokens->e_code);
// }

/* my data was stored in cmd , but if pipe exist then we store in
pipe->cmd1(start < pipe(position) and cmd2(pipe(position + 1) < NULL || next_pipe)) 
sso if (pipe exist), we use pipe to process the cmds and exectute but if(!pipe exist)
we use the copy of cmd and then set up child fork is necessary and then execute */
// int	execute_command(t_infos *tokens, char ***envp) {
//     pid_t	pid;
// 	int		status;

// 	if (tokens->pipe_index > 0)
// 		tokens->e_code = iterate_pipe_index(tokens, envp);
// 	else
// 	{
// 		handle_builtin(tokens->commands[0], tokens, envp, &status);
// 		if ((status == -5) || (status == 1))
//             return (status);
//         pid = handle_forked_process(tokens, envp);
//         if (pid > 0)
// 		{
// 			return (handle_parent_process(pid, tokens));
// 		}
// 	}
// 	return (tokens->e_code);
// }

/* my data was stored in cmd , but if pipe exist then we store in
pipe->cmd1(start < pipe(position) and cmd2(pipe(position + 1) < NULL || next_pipe)) 
sso if (pipe exist), we use pipe to process the cmds and exectute but if(!pipe exist)
we use the copy of cmd and then set up child fork is necessary and then execute */
// int	execute_command(t_infos *tokens)
// {
// 	pid_t	pid;
// 	int		status;

// 	if (tokens->pipe_index > 0)
// 		tokens->e_code = iterate_pipe_index(tokens, envp);
// 	else
// 	{
// 		handle_builtin(tokens->commands[0], tokens, envp, &status);
// 		if (status == -5)
// 			return (status);
// 		else if (status == 1)
// 			return (status);
// 		pid = fork();
// 		if (pid == 0)
// 		{
// 			setup_signal_handlers_child();
// 			tokens->e_code = run_child(tokens, envp);
// 			exit (tokens->e_code);
// 		}
// 		else if (pid > 0)
// 		{
// 			signal(SIGINT, SIG_IGN);
// 			waitpid(pid, &status, 0);
// 			if (status == 256)
// 				return (-5);
// 			signal(SIGINT, handle_sigint);
			
// 			if (WIFEXITED(status)){
// 				tokens->e_code = WEXITSTATUS(status);}
// 			else if (WIFSIGNALED(status)) {
//                if (WTERMSIG(status) == SIGINT) {
//             	g_int = 0;  // Child exited due to Ctrl + C, clear g_int in parent
//         }
//             }
// 			if (g_int)
// 			{
//                 tokens->e_code = 130;
// 				g_int = 0;
//             }
// 			return (tokens->e_code);
// 		}
// 	}
// 	return (tokens->e_code);
// }


// void	handle_redirections(t_command *cmd)
// {
// 	int	i;
// 	int	fd;

// 	i = 0;
// 	while (i < cmd->redir_count)
// 	{
// 		if (cmd->redir_cmd[i]->type == INPUT_REDIR)
// 		{
// 			fd = open(cmd->redir_cmd[i]->file, O_RDONLY);
// 			if (fd == -1)
// 			{
// 				errors("Error opening file for input redirection\n");
// 			}
// 			dup2(fd, STDIN_FILENO);
// 		}
// 		else if (cmd->redir_cmd[i]->type == OUTPUT_REDIR)
// 		{
// 			fd = open(cmd->redir_cmd[i]->file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
// 			if (fd == -1)
// 			{
// 				errors("Error opening file for output redirection\n");
// 			}
// 			dup2(fd, STDOUT_FILENO);
// 		}
// 		close(fd);
// 		i++;
// 	}
// }